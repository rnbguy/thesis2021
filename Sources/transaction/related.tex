%!TEX root = Thesis.tex

\section{Transactional System}

\cite{DBLP:conf/concur/Cerone0G15} give the first formalization of the criteria we consider in this paper, using the specification methodology of \cite{DBLP:conf/popl/BurckhardtGYZ14}. This formalization uses two auxiliary relations, a \emph{visibility} relation which represents the fact that a transaction ``observes'' the effects of another transaction and a \emph{commit order}, also called arbitration order, like in our case. Executions are abstracted using a notion of history that includes only a session order and the adherence to some consistency criterion is defined as the existence of a visibility relation and a commit order satisfying certain axioms. Motivated by practical goals, our histories include a write-read relation, which enables more uniform and in our opinion, more intuitive, axioms to characterize consistency criteria. Our formalizations are however equivalent with those of~\cite{DBLP:conf/concur/Cerone0G15} (a formal proof of this equivalence is presented in the extended version of this paper~\cite{DBLP:journals/corr/abs-1908-04509}). Moreover, \cite{DBLP:conf/concur/Cerone0G15} do not investigate algorithmic issues as in our paper.

\cite{DBLP:journals/jacm/Papadimitriou79b} showed that checking serializability of an execution is NP-complete. Moreover, it identifies a stronger criterion called \emph{conflict serializability} which is polynomial-time checkable. Conflict serializability assumes that histories are given as sequences of operations and requires that the commit order be consistent with a \emph{conflict-order} between transactions defined based on this sequence (roughly, a transaction $\tr_1$ is before a transaction $\tr_2$ in the conflict order if it accesses some variable $\xvar$ before $\tr_2$ does). This result is not applicable to distributed databases where deriving such a sequence between operations submitted to different nodes in a network is impossible.

\cite{DBLP:conf/popl/BouajjaniEGH17} showed that checking several variations of causal consistency on executions of a \emph{non-transactional} distributed database is polynomial time (they also assume that every value is written at most once). 
%The also rely on the specification framework in \cite{DBLP:conf/popl/BurckhardtGYZ14}. 
Assuming singleton transactions, our notion of CC corresponds to the causal convergence criterion in~\cite{DBLP:conf/popl/BouajjaniEGH17}. Therefore, our result concerning CC can be seen as an extension of this result concerning causal convergence to transactions.

There are some works that investigated the problem of checking consistency criteria like sequential consistency and linearizability in the case of shared-memory systems. \cite{DBLP:journals/siamcomp/GibbonsK97} showed that checking linearizability of the single-value register type is NP-complete in general, but polynomial time for executions where every value is written at most once. Using a reduction from serializabilty, they showed that checking sequential consistency is NP-complete even when every value is written at most once. \cite{DBLP:journals/pacmpl/EmmiE18} extended the result concerning linearizability to a series of abstract data types called collections, that includes stacks, queues, key-value maps, etc. Sequential consistency reduces to serializability for histories with singleton transactions (i.e., formed of a single read or write operation). Therefore, our polynomial-time result for checking serializability of bounded-width histories (Corollary~\ref{cor:ser}) implies that checking sequential consistency of histories with a bounded number of threads is polynomial time. The latter result has been established independently by \cite{DBLP:journals/pacmpl/AbdullaAJLNS19}.

The notion of \emph{communication graph} is inspired by the work of \cite{DBLP:journals/pacmpl/ChalupaCPSV18}, which investigates partial-order reduction (POR) techniques for multi-threaded programs. In general, the goal of partial-order reduction~\cite{DBLP:conf/popl/FlanaganG05} is to avoid exploring executions which are equivalent w.r.t. some suitable notion of equivalence, e.g., Mazurkiewicz trace equivalence~\cite{DBLP:conf/ac/Mazurkiewicz86}. They use the acyclicity of communication graphs to define a class of programs for which their POR technique is optimal. The algorithmic issues they explore are different than ours and they don't investigate biconnected components of this graph as in our results.
