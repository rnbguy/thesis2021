%!TEX root = ../../Thesis.tex

\section{Intractability for Registers, Sets, Flags, and Counters}
\label{sec:intractability}

In this section we demonstrate that checking the consistency is intractable for many widely-used data types. While this is not completely unexpected, since some related consistency-checking problems like sequential consistency are also intractable~\cite{DBLP:journals/siamcomp/GibbonsK97}, this contrasts recent tractability results for checking strong consistency (i.e.,~linearizability) of common non-replicated data types like sets, maps, and queues~\cite{DBLP:journals/pacmpl/EmmiE19}. In fact, in many cases we show that intractability even holds if the number of replicas is fixed.

Our proofs of intractability follow the general structure of Gibbons and Korach’s proofs for the intractability of checking sequential consistency (SC) for atomic registers with read and write operations~\cite{DBLP:journals/siamcomp/GibbonsK97}. In particular, we reduce a specialized type of NP-hard propositional satisfiability (SAT) problem to checking whether histories are admitted by a given data type. While our construction borrows from Gibbons and Korach’s, the adaptation from SC to CRDT consistency requires a significant extension to handle the consistency relaxation represented by abstract executions: rather than a direct sequencing of threads’ operations, CRDT consistency requires the construction of three separate relations: read-from, happens-before, and linearization.

Technically, our reductions start from the 1-in-3 SAT problem~\cite{DBLP:books/fm/GareyJ79}: given a propositional formula $\bigwedge_{i=1}^{m} (\alpha_i \lor \beta_i \lor \gamma_i)$ over variables $x_1, \ldots, x_n$ with only positive literals, i.e.,~$\alpha_i, \beta_i, \gamma_i \in \set{ x_1, \ldots, x_n }$, does there exist an assignment to the variables such that exactly one of $\alpha_i, \beta_i, \gamma_i$ per clause is assigned $\mathit{true}$? The proofs of Theorems~\ref{thm:3sat-to-flags} and~\ref{thm:3sat-to-counter} reduce 1-in-3 SAT to CRDT consistency checking.

\vspace{-1mm}
\begin{theorem}
  \label{thm:3sat-to-flags}

  The admissibility problem is NP-hard when the number of replicas is fixed for the following data types: Add-Wins Set, Remove-Wins Set, Enable-Wins Flag, Disable-Wins Flag, Multi-Value Register, and Last-Writer-Wins Register.
\vspace{-1mm}
\end{theorem}

\begin{proof}

  We demonstrate a reduction from the 1-in-3 SAT problem. For a given problem $p = \bigwedge_{i=1}^{m} (\alpha_i \lor \beta_i \lor \gamma_i)$ over variables $x_1, \ldots, x_n$, we construct a 3-replica history $h_p$ of the flag data type — either enable- or disable-wins — as illustrated in Figure~\ref{fig:3sat-to-flags}. The encoding includes a flag variable~$x_j$ for each propositional variable $x_j$, along with a per-replica flag variable $y_j$ used to implement synchronization barriers. Intuitively, executions of $h_p$ proceed in $m+1$ rounds: the first round corresponds to the assignment of a truth valuation, while subsequent rounds check the validity of each clause given the assignment. The reductions to sets and registers are slight variations on this proof, in which the \textrm{Read}, \textrm{Enable}, and \textrm{Disable} operations are replaced with \textrm{Contains}, \textrm{Add}, and \textrm{Remove}, respectively, and \textrm{Read} and \textrm{Writes} of values 1 and 0, respectively.
  
  Since the flag data type does not constrain the linearization relation of its abstract executions, we regard only the read-from and happens-before components. It is straightforward to verify that the happens-before relations of $h_p$’s abstract executions necessarily order:
  \vspace{-1.5mm}
  \begin{enumerate}

    \item every pair of operations in distinct rounds — due to barriers; and

    \item every operation in a given round, over all replicas, without interleaving the operations of distinct replicas within the same round — since a replica’s reads in a given round are only consistent with the other replicas’ after the re-enabling and -disabling of flag variables.
\vspace{-1.5mm}
  \end{enumerate}

  In other words, replicas appear to execute atomically per round, in a round-robin fashion. Furthermore, since all operations in a given round happen before the operations of subsequent rounds, the values of flag variables are consistent across rounds — i.e.,~as read by the first replica to execute in a given round — and determined in the initial round either by conflict resolution — i.e.,~enable- or disable-wins — or by happens-before, in case conflict resolution would have been inconsistent with subsequent reads.

  \begin{figure}[t]
    \centering
    {\scriptsize\input{Sources/crdt/figures/3sat-to-flags}}
         \vspace{-1mm}
    \caption{The encoding of a 1-in-3 SAT problem $\bigwedge_{i=1}^{m} (\alpha_i \lor \beta_i \lor \gamma_i)$ over variables $x_1, \ldots, x_n$ as a 3-replica history of a flag data type. Besides the flag variable $x_j$ for each propositional variable $x_j$, the encoding adds per-replica variables $y_j$ for synchronization barriers.}
    \label{fig:3sat-to-flags}
    \vspace{-4mm}
  \end{figure}

  It suffices to show that the constructed history $h_p$ is admitted if and only if the given problem $p$ is satisfiable.

  \begin{lemma}
    \label{crdt:flag:npc-proof:lemma1}
    The \textrm{Read}s of each barrier reads from the \textrm{Enable}s or \textrm{Disable}s of the same barrier. 
  \end{lemma}

  \begin{proof}
    Base case. Note, $y_i$ is enabled or disabled only replica $i$. At barrier 1, if the $\mathrm{Read}(y_j)$ at replica $i$ are read (from a replica $j$) barrier other than 1, the history must have crossed a $\mathrm{Read}(y_i) = true$ and $\mathrm{Read}(y_i) = false$ at replica $j$. Because the each barrier alternates the values of $y_i$. The first \textrm{Read} makes sure $\mathrm{Enable}(y_i)$ is visible to replica $j$. But if barrier 1 is not finished at replica $i$, $y_i$ was never set to $false$ again. So the second \textrm{Read} is not possible. So $y_i$s at barrier 1 are read from barrier 1.
    
    Inductive step. Barrier $k$ always reads from barrier $k$ itself. Now at $\mathrm{Read}(y_j)$ of barrier $(k+1)$, the history is visible upto the write of $y_j$ from barrier $k$. Without loss of generality, let's assume, barrier $k$ writes $false$ value. A $\mathrm{Read}(y_j)$ at replica $i$ in the next barrier $(k+1)$ reads a flipped value of the last barrier. So $\mathrm{Read}(y_j)$ at barrier $(k+1)$ must read from a barrier strictly greater than $k$. Using the similar logic from base case, if $\mathrm{Read}(y_j)$ is read from a barrier other than $(k+1)$ at replica $j$, the history must have crossed a $\mathrm{Read}(y_i) = true$ and $\mathrm{Read}(y_i) = false$ at replica $j$. Buf if barrier $(k+1)$ is not finished replica $i$, $y_i$ was never set to $false$ again after barrier $k$. So the second read is not possible. So $y_i$s at barrier $(k+1)$ are read from barrier $(k+1)$ itself. The argument stays the same when barrier $k$ writes $true$ value.
  \end{proof}

  \begin{lemma}
    \label{crdt:flag:npc-proof:lemma2}
    After the completion of sub-history till each round has same assignment for $x_i$s.
  \end{lemma}

  \begin{proof}
    Base case. $k = 1$. At the end of barrier 1, lemma \ref{crdt:flag:npc-proof:lemma1} makes sure, each replica sees the complete round 0.
    Since the \textrm{Read} operations from replica $0, 1, 2$ demands the variable $\alpha_1, \beta_1, \gamma_1$ be true respectively, all the \textrm{Read}s of round 1 can not be happened-before all the writes of round 1.

    Without loss of generality, let's assume the writes from replica 0 are happened first. So replica 0 is finished with its reads and only $\alpha_1$ is set to true and $\beta_1, \gamma_1$ are set to false. The way the reads and writes are organized, the reads from other replicas can not progress until all the writes in replica 0 are finished.

    Now once replica 0 is finished, only replica 1 can finish its reads. Because replica 2 still has to read $\gamma$ to be true. And replica 1 reads the modified values from replica 0. After replica 1 finishes its reads, with the similar argument, replica 2 can not finish its reads, until replica 1 finishes its writes and replica 2 reads the modified values from replica 1.

    Similarly starting from replica 1 and 2, the happens-before goes from replica 1 to replica 2 and then replica 0 and replicas 2 to replica 0 and then replica 1 respectively.

    So the writes in each replica happens in sequence at each round. Since each variable is \textrm{Enable}d and \textrm{Disable}d once, at the end of each round, the assignment stays the same as after round 0.

    Inductive step. Because of lemma \ref{crdt:flag:npc-proof:lemma1}, round $(k+1)$ can only see upto barrier $(k+1)$, but not barrier $(k+2)$. Till round $k$, the assignment stays the same as per our hypothesis. After that argument is similar as base case. Without loss of generality, if writes of replica 0 happened-before among the writes of round $(k+1)$ the happene-before relation goes like before from replica 0 to replica and replica 2. The writes in each replica happens in sequence at each round. Since each variable is \textrm{Enable} and \textrm{Disable} once, at the end of each round, the assignment stays the same as after round $(k+1)$.
  \end{proof}

  
  \begin{lemma}
    \label{crdt:flag:npc-proof:lemma3}
    $p = \bigwedge_{i=1}^{j \leq m} (\alpha_i \lor \beta_i \lor \gamma_i)$ is satisfied if and only if the sub-history till round j is admissible.
  \end{lemma}

  \begin{proof}
    We proof each direction by induction.

    If direction.
    We construct an assignment for $x_i$ for the SAT formula based on the $hb$ in Round 0. $x_i$ is false if and only if $(Enable(x_i), Disable(x_i)) \in \hb$. Note if this is true, then after round 0 is completed, the values set to $x_i$ in the Enable-wins Flag history is same as the assignment we just constructed for the SAT formula. We show if history is admissible, that assignment also satisfies the SAT formula.

    Base case. When $j = 1$, \ie there is only one clause. Barrier 1 does not modifiy $x_i$. So the first replica which finishes all of its \textrm{Read}s, will have no \textrm{Enable} or \textrm{Disable} on $x_i$ before it. Lemma \ref{crdt:flag:npc-proof:lemma1} makes sure, that replica sees the whole of round 0. The \textrm{Read}s from that replica makes sure exactly one of the literal in clause 1 is set to true. So first clause is satisfied.

    Inductive step. Lemma \ref{crdt:counter:npc-proof:lemma2} makes sure, after round $j$, the $x_i$ assignment stays the same as all the rounds before. So at round $(j+1)$, just like our base case, we can show the clause $(j+1)$ is satisfied. By inductive hypothesis, first $j$ clauses are already satisfied by the same assignment. So the sub-formula containing the first $(k+1)$ clauses is also satisfied.

    Only if direction.
    Base case. j = 1. When $\bigwedge_{i=1}^{1} (\alpha_i \lor \beta_i \lor \gamma_i)$ is satisfied, that means, there exists an assignment for which all the first clause have exactly one literal set to true. First for all, to assign the corresponding values to $x_i$, we construct the $\hb$ such way that if $x_i = false$ in the SAT formula, then we make $Enable(x_i)$ in Replica 0 visible to $Disable(x_i)$ in Replica 1, \ie $(Enable(x_i), Disable(x_i)) \in \hb$. This is make sure value of $x_i$ is $false$ after Barrier 1. Similarly we $(Disable(x_i), Enable(x_i)) \in \hb$ if $x_i = true$ in SAT formula. Note this does not introduce any cycle in $\hb$ because $x_i$s are \textrm{Enable}d and \textrm{Disable}d in same order in Replica 0 and Replica 1.

    Now at barrier i, we add all the \textrm{Enable} happens-before all the \textrm{Read} in $\hb$. This also makes sure there is no cycle.

    Now for each round 1, if $\alpha_1$ is true in clause 1, then we add the round 1 of replica 0 happens-before the round 1 of replica 1 in $\hb$, then the round 1 of replica 1 happens-before the round 1 of replica 2 in $\hb$. This makes the history admissible because, at first $\alpha_1$ is true and $\beta_1$ and $\gamma_1$ are false. So the reads of round 1 in replica 0 goes ahead. Then the updates of round 1 in replica 0 make $\alpha_1$ false and $\beta_1$ true. $\gamma_1$ stays false. So now, the reads of round 1 in replica 1 can go ahead. Similarly the happens before relation works between replica 1 and replica 2. So the sub-history till round 1 is admissible.
    
    If $\beta_1$ is true then the replica order is 1, 2 then 0 and $\gamma_1$ is true, it is 2, 0 and then 1.
    
    So the sub-history till round 1 stays admissible.

    Inductive step. By inductive hypothesis, the sub-history till round $j$ is admissible. So it has a happens before relation. We take that $\hb$ and extend it for the sub-history till round $(j+1)$. From lemma \label{crdt:flag:npc-proof:lemma2}, after each round, the $x_i$ assignment stays the same. So the argument stays the same as the base case. At barrier $(j+1)$, we add all the \textrm{Enable} or \textrm{Disable} happens-before all the \textrm{Read} in $\hb$. For each round $(j+1)$, if $\alpha_{j+1}$ is true in clause $(j+1)$, then the round $(j+1)$ in replica 0 happens-before the round $(j+1)$ in replica 1, then the round $(j+1)$ in replica 1 happens-before the round $(j+1)$ in replica 2. As the base case, the order changes when $\beta_(j+1)$ or $\gamma_(j+1)$ is true. So the sub-history till round $(j+1)$ is admissible.
  \end{proof}

Theorem \ref{thm:3sat-to-flags} is a direct consequence of lemma \ref{crdt:flag:npc-proof:lemma3} when $j = m$. 


%   In the “if” direction, let $\vec{r} \in \set{0,1,2}^m$ be the positions of positively-assigned variables in each clause, e.g.,~$r_i = 0$ implies $\alpha_i = \mathit{true}$ and $\beta_i = \gamma_i = \mathit{false}$. We construct an abstract execution $e_{\vec{r}}$ in which the happens-before relation sequences the operations of replica~$r_i$ before those of $r_i + 1 \bmod 3$, and in turn before $r_i + 2 \bmod 3$. In other words, the replicas in round $i$ appear to execute in left-to-right order from starting with the replica~$r_i$, whose reads correspond to the satisfying assignment of $(\alpha_i \lor \beta_i \lor \gamma_i)$. The read-from relation of $e_{\vec{r}}$ relates each $\mathrm{Read}(x_j) = \mathit{true}$ operation to the most recent $\mathrm{Enable}(x_j)$ operation in happens-before order, which is unique since happens-before sequences the operations of all rounds; the case for $\mathrm{Read}(x_j) = \mathit{false}$ and $\mathrm{Disable}(x_j)$ is symmetric. It is then straightforward to verify that $e_{\vec{r}}$ satisfies the axioms of the enable- or disable-wins flag, and thus $h_p$ is admitted.

%   In the “only if” direction, let $e$ be an abstract execution of $h_p$, and let $\vec{r} \in \set{0,1,2}^m$ be the replicas first to execute in each round according to the happens-before order of $e$. It is straightforward to verify that the assignment in which a given variable is set to true if{f} the replica encoding its positive assignment in some clause executes first in its round, i.e.,
% \vspace{-1mm}
%   \begin{align*}
%     x_j = \left\{
%     \begin{array}{ll}
%       \mathit{true} \qquad & \text{ if } \exists i. (r_i = 0 \land \alpha_i = x_j) \lor (r_i = 1 \land \beta_i = x_j) \lor (r_i = 2 \land \gamma_i = x_j) \\
%       \mathit{false} & \text{ otherwise,}
%     \end{array}
%     \right. \\[-7mm]
%   \end{align*}
%   is a satisfying assignment to $p$.
% \vspace{-1mm}
\end{proof}

Theorem~\ref{thm:3sat-to-flags} establishes intractability of consistency for the aforementioned sets, flags, and registers, independently from the number of replicas. In contrast, our proof of Theorem~\ref{thm:3sat-to-counter} for counter data types depends on the number of replicas, since our encoding requires two replicas per propositional variable. Intuitively, since counter increments and decrements are commutative, the initial round in the previous encoding would have fixed all counter values to zero. Instead, the next encoding isolates initial increments and decrements to independent replicas.
% Todo:
The weaker result is indeed tight since checking counter consistency with a fixed number of replicas is polynomial time, as Section~\ref{sec:counter} demonstrates.

\vspace{-1mm}
\begin{theorem}
  \label{thm:3sat-to-counter}

  The admissibility problem for the Counter data type is NP-hard.

\vspace{-1mm}
\end{theorem}

We demonstrate a reduction from the 1-in-3 SAT problem. For a given problem $p = \bigwedge_{i=1}^{m} (\alpha_i \lor \beta_i \lor \gamma_i)$ over variables $x_1, \ldots, x_n$, we construct a history $h_p$ of the counter data type over $2n+3$ replicas, as illustrated in Figure~\ref{fig:3sat-to-counter}.

    \begin{figure}[t]
      \centering
      {\scriptsize\input{Sources/crdt/figures/3sat-to-counter}}
     \vspace{-1mm}
      \caption{The encoding of a 1-in-3 SAT problem $\bigwedge_{i=1}^{m} (\alpha_i \lor \beta_i \lor \gamma_i)$ over variables $x_1, \ldots, x_n$ as the history of a counter over $2n+3$ replicas. Besides the counter variables $x_j$ encoding propositional variables $x_j$, the encoding adds a variable $y$ encoding the number of initial increments and decrements, and a variable $z$ to implement synchronization barriers.}
      \label{fig:3sat-to-counter}
     \vspace{-4mm}
    \end{figure}

     Besides the differences imposed due to the commutativity of counter increments and decrements, our reduction follows the same strategy as in the proof of Theorem~\ref{thm:3sat-to-flags}: the happens-before relation of $h_p$’s abstract executions order every pair of operations in distinct rounds (of Replicas 0–2), and every operation in a given (non-initial) round. As before, Replicas 0–2 appear to execute atomically per round, in a round-robin fashion, and counter variables are consistent across rounds. The key difference is that here abstract executions’ happens-before relations only relate the operations of either Replica~$2j\!+\!1$ or $2j\!+\!2$, for each $j = 1, \ldots, n$, to operations in subsequent rounds: the other’s operations are never observed by other replicas. Our encoding ensures that exactly one of each is observed by ensuring that the counter~$y$ is incremented exactly $n$ times — and relying on the fact that every variable appears in some clause, so that a read that observed neither or both would yield the value zero, which is inconsistent with $h_p$. Otherwise, our reasoning follows the proof of Theorem~\ref{thm:3sat-to-flags}, in which the read-from relation selects all increments and decrements of the same counter variable in happens-before order.
\vspace{-2mm}

\begin{lemma}
  \label{crdt:counter:npc-proof:lemma1}
  The \textrm{Read}s of each barrier reads from the \textrm{Inc}s or \textrm{Dec}s of the same barrier. 
\end{lemma}

\begin{proof}
  Base case. At barrier 1, let's assume replica $i$'s $\mathrm{Read}(z) = 3$ happened-before at first. Then, it must have been three Inc(z) before it. Since the $\mathrm{Read}(z) = 3$ are not performed, the only $Inc(z)$ are available from same barrier but from other replicas. If the second $\mathrm{Read}(z) = 3$ reads from other barrier, then the first replica progressed through some other barrier which $\mathrm{Read}(z) = 0$, which is not possible. So the second read also reads from barrier 1. Similarly the third read also read from barrier 1.

  Inductive step. This step is very similar to the induction step of lemma \ref{crdt:flag:npc-proof:lemma1}. Once we prove the base case, we show that the possible reads can only happen from barriers after the current barrier. Then just like the base, we prove reading from any barrier after the current one is not possible. 
\end{proof}

\begin{lemma}
  \label{crdt:counter:npc-proof:lemma2}
  At the completion of each sub-history till each round has same assignment for $x_i$s.
\end{lemma}

\begin{proof}
  The proof of lemma \ref{crdt:counter:npc-proof:lemma2} and lemma \ref{crdt:counter:npc-proof:lemma3} are very similar to the proof of lemma \ref{crdt:flag:npc-proof:lemma2} and \ref{crdt:flag:npc-proof:lemma3}. Instead of $\mathrm{Enable}$, $\mathrm{Distable}$, $\mathrm{Read}=true$ and $\mathrm{Read}=false$, we have two $\mathrm{Inc}$s, two $\mathrm{Dec}$s, $\mathrm{Read}=1$, $\mathrm{Read}=-1$. Otherwise the proof stays the same.
\end{proof}

\begin{lemma}
  \label{crdt:counter:npc-proof:lemma3}
  $p = \bigwedge_{i=1}^{j \leq m} (\alpha_i \lor \beta_i \lor \gamma_i)$ is satisfied if and only if the sub-history till round j is admissible.
\end{lemma}

\begin{proof}
  Theorem \ref{thm:3sat-to-counter} is a direct consequence of lemma \ref{crdt:counter:npc-proof:lemma3} when $j = m$.
\end{proof}
